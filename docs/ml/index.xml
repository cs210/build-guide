<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ML Engineering on CS 210 Build Guide</title>
    <link>https://cs210.github.io/docs/ml/</link>
    <description>Recent content in ML Engineering on CS 210 Build Guide</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 08 Jan 2025 10:55:07 -0800</lastBuildDate>
    <atom:link href="https://cs210.github.io/docs/ml/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Basic ML</title>
      <link>https://cs210.github.io/docs/ml/basic/</link>
      <pubDate>Wed, 08 Jan 2025 10:55:07 -0800</pubDate>
      <guid>https://cs210.github.io/docs/ml/basic/</guid>
      <description>&lt;h1 id=&#34;basic-ml&#34;&gt;Basic ML&lt;/h1&gt;&#xA;&lt;p&gt;Below are some snippets for common ML use cases such as NLP &amp;ndash; namely, LLMs &amp;ndash; computer vision, and even standard statistical ML.&lt;/p&gt;&#xA;&lt;h2 id=&#34;large-language-models-llms&#34;&gt;Large Language Models (LLMs)&lt;/h2&gt;&#xA;&lt;p&gt;For initial iteration, using LLM APIs is probably the best way to go. There are several models out there, each with their own strengths. Below is an example using the &lt;a href=&#34;https://platform.openai.com/docs/quickstart?language-preference=python&#34;&gt;OpenAI API&lt;/a&gt; to make a call to a language model:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; openai &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; OpenAI&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;client &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; OpenAI()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;completion &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;chat&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;completions&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;create(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    model&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;gpt-4o-mini&amp;#34;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    messages&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;role&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;system&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;content&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;You are a helpful assistant.&amp;#34;&lt;/span&gt;},&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;role&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user&amp;#34;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;content&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Write a haiku about recursion in programming.&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(completion&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;choices[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;message)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you continue to iterate, you may want to leverage the power of open-source models. For this, Hugging Face &amp;ndash; in particular, the &lt;a href=&#34;https://huggingface.co/sentence-transformers&#34;&gt;SentenceTransformers&lt;/a&gt; module &amp;ndash; will be your best friend. Just specify your language model and you&amp;rsquo;ll be good to go:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Extending LLMs</title>
      <link>https://cs210.github.io/docs/ml/extending-llms/</link>
      <pubDate>Wed, 08 Jan 2025 10:55:07 -0800</pubDate>
      <guid>https://cs210.github.io/docs/ml/extending-llms/</guid>
      <description>&lt;h1 id=&#34;extending-llms&#34;&gt;Extending LLMs&lt;/h1&gt;&#xA;&lt;p&gt;Below are some ways to go beyond just LLMs and use your custom data. These include methods such as Retrieval Augmented Generation (RAG), finetuning, and even searching over tabular data.&lt;/p&gt;&#xA;&lt;h2 id=&#34;retrieval-augmented-generation&#34;&gt;Retrieval Augmented Generation&lt;/h2&gt;&#xA;&lt;p&gt;Language models are typically pretrained on vast amounts of data, but they may require updated information or data tailored to a specific use case. Retraining a language model on a large amount of data might prove to be expensive. In many scenarios, extending large language models with external knowledge bases becomes essential to provide relevant and accurate outputs. This is where &lt;strong&gt;Retrieval-Augmented Generation (RAG)&lt;/strong&gt; comes into play. RAG consists of two key components: a retrieval system to identify relevant items or contextual information and a mechanism to integrate that information into the model&amp;rsquo;s output, often through prompting.&lt;/p&gt;</description>
    </item>
    <item>
      <title>General Advice</title>
      <link>https://cs210.github.io/docs/ml/general-advice/</link>
      <pubDate>Wed, 08 Jan 2025 10:55:07 -0800</pubDate>
      <guid>https://cs210.github.io/docs/ml/general-advice/</guid>
      <description>&lt;h1 id=&#34;general-advice&#34;&gt;General Advice&lt;/h1&gt;&#xA;&lt;p&gt;Below are some general tips, aggregated from industry experts and 210 alums.&lt;/p&gt;&#xA;&lt;h2 id=&#34;buy-first-not-build&#34;&gt;Buy first, not Build.&lt;/h2&gt;&#xA;&lt;p&gt;For initial functional prototyping and for most of the former part of your application&amp;rsquo;s lifecycle, lean on existing APIs to do a lot of the heavy lifting. These models are already quite powerful and are able to handle almost all of the requests you send it. If certain users or design partners necessitate even more advanced functionality, though, consider working and finetuning your own LLMs.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
